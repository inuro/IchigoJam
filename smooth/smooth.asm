@XY		 ' 	
	push {R4}	 ' 	R4を退避
	R0=8	 ' 	
	R0=R0<<8	 ' 	#800
	R0+=250	 ' 	#800+#FAが変数Xの位置
	R0=R1+R0	 ' 	仮想メモリ #800+250 の変数Xの実アドレス位置を計算
	R2=[R0+0]W	 ' 	変数Xの16bitの数をR2へ入れる
	R3=[R0+1]W	 ' 	変数Yの16bitの数をR3へ入れる。
	R1=R2	 ' 	Xは後でも使うので、退避(push{R2}でも良いが遅い
	R2=R2>>3	 ' 	X=X/8
	R3=R3<<5	 ' 	Y=Y*32
	R3=R2+R3	 ' 	VRAMのベース#900からのオフセット値をR3に格納
		 ' 	
@ADR		 ' 	
	R0+=6	 ' 	#仮想アドレス8FAの実位置が入っているので、+6してVRAMのベース#900の実アドレスを計算
	R3+=R0	 ' 	#900+X/8+Y*#20のPEEK先アドレス
	R2=R1	 ' 	退避していたオリジナルのXの値を取得
	R1=7	 ' 	X%8の為に、マスク値の7を格納
	R2&=R1	 ' 	X%8を計算
	R4=#FF		当たり判定用のR4を生成
	R4=R4<<8		自機が8ビット境界左端にいる状態
	R4>>=R2		自機の位置を示す16ビットフラグ
	R2+=224	 ' 	表示すべきキャラクタコード（左）を計算。右はこれに更に+8
	R0=0	 ' 	当たり判定フラグの初期化
@LEFT		 ' 	
	R1=[R3]	 ' 	#900+X/8+Y*#20の位置に現在あるキャラクタを取得
	R1+=0	 ' 	
	IF !0 GOTO @L2	 ' 	既に存在していれば描画せず次へ
	[R3]=R2	 ' 	#900+X/8+Y*#20の位置に自機パターン（左）を描画
	GOTO @RIGHT	 ' 	
@L2		 ' 	
	R0=#FF	 ' 	当たり判定用のフラグ
	R0=R0<<8	 ' 	左半分8ビットシフト
@RIGHT		 ' 	
	R1=[R3+1]	 ' 	
	R1+=0	 ' 	
	IF !0 GOTO @R2	 ' 	既に存在していれば描画せず次へ
	R2+=8	 ' 	自機パターン（右）は8バイト先
	[R3+1]=R2	 ' 	#900+X/8+1+Y*#20の位置に自機パターン（右）を描画
	GOTO @END	 ' 	
@R2		 ' 	
	R0+=#FF	 ' 	当たり判定用のフラグ。右半分8ビットをそのまま加算
@END		 ' 	
	R0&=R4	 ' 	当たり判定用に論理和を取った値を返す。BASICのP=(#FF00>>(X%8))&Z部分と等価。自機と障害物が交錯した部分だけにビットが立っている
	pop{R4}	 ' 	R4を復元
	RET	 ' 	RETURN
